C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil_V5\C51\BIN\C51.EXE main.c OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG TABS(2)

line level    source

   1          /*********************************************************************
   2          
   3          ¹¦ÄÜ:
   4            RFIDÖ÷¶ÁÐ´Æ÷¶ÁÐ´³ÌÐò
   5          
   6          ËµÃ÷:
   7            1.Í¨¹ý´®¿ÚÉÏ±¨Ö÷¶ÁÐ´Æ÷Óë´Ó¶ÁÐ´Æ÷Ê¶±ðµ½µÄ±êÇ©ÐÅÏ¢
   8            2.Ïò±êÇ©ÏÂ·¢ÐÝÃß/»½ÐÑÖ¸Áî,ÇÐ»»±êÇ©¹¤×÷×´Ì¬
   9            3.Ïò±êÇ©ÏÂ·¢ÉäÆµÐÅºÅÇ¿¶ÈÅäÖÃÖ¸Áî,µ÷½Ú±êÇ©ÐÅºÅ·¢Éä¾àÀë
  10            4.Í¨¹ýSPI½ÓÊÜ´Ó¶ÁÐ´Ä£¿éÊ¶±ðµ½µÄ±êÇ©IDÐÅÏ¢
  11          
  12          //P0.4, RXD, set as input
  13          //P0.3, TXD, set as output
  14          
  15          **********************************************************************/
  16          
  17          #include <Nordic\reg24le1.h>
  18          #include <stdint.h>
  19          #include "API.h"
  20          #include <absacc.h>
  21          
  22          #define PIN32
  23          
  24          #ifdef  PIN32
  25          sbit  spi_cs= P0^6;
  26          sbit LED4 = P0^6;      
  27          sbit  spi_cs_slave=P1^1;   
  28          
  29          #define p0dir 0xb0
  30          #define p1dir 0xf3
  31          #endif
  32          
  33          #define INTERRUPT_RFIRQ 9
  34          #define TX_ADR_WIDTH    8           // RFÊÕ·¢µØÖ·¹²8 bytes 
  35          #define TX_PLOAD_WIDTH  32            // Êý¾Ý°ü³¤¶ÈÎª9 bytes
  36          
  37          uint8_t const TX_ADDRESS[TX_ADR_WIDTH]  = {0xD0,0xEC,0xC8,0xB5,0xC7,0xBF,0x51,0x51}; // ¶¨ÒåRFÊÕ·¢µØÖ·
  38          uint8_t const RX_ADDRESS[TX_ADR_WIDTH]  = {0xD2,0xF8,0xD0,0xD0,0xBD,0xA3,0xBF,0xCD}; // ¶¨ÒåRFÊÕ·¢µØÖ·0
  39          //uint8_t const RX_ADDRESS_P1[TX_ADR_WIDTH]  = {0xD2,0xF8,0xD0,0xD0,0xBD,0xA3,0x11,0x11}; // ¶¨ÒåRFÊÕ·¢µØÖ
             -·1
  40          
  41          uint8_t data rx_buf[TX_PLOAD_WIDTH];
  42          uint8_t data tx_buf[9]={0x99};
  43          //uint8_t data_buf[10]  = {0x00,0x01,0x00,0x01,0x00,0x04,0x03,0x02,0x01,0x00};  //Ð´ÈëNVN´æ´¢ÇøÓòµÄÊý¾Ý
  44          
  45          uint8_t bdata sta;
  46          sbit  RX_DR =sta^6;
  47          sbit  TX_DS =sta^5;
  48          sbit  MAX_RT  =sta^4;
  49          
  50          /**************************************************
  51          ¹¦ÄÜ£ºÑÓÊ±
  52          **************************************************/
  53          void delay(uint16_t x)
  54          {
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 2   

  55   1          uint16_t i,j;
  56   1          i=0;
  57   1          for(i=0;i<x;i++)
  58   1          {
  59   2             j=108;
  60   2                 ;
  61   2             while(j--);
  62   2          }
  63   1      }
  64          /**************************************************
  65          ¹¦ÄÜ£ºÓ²¼þSPI¶ÁÐ´
  66          **************************************************/
  67          uint8_t SPI_RW(uint8_t value)
  68          {
  69   1        SPIRDAT = value;
  70   1                                     
  71   1        while(!(SPIRSTAT & 0x02));            // µÈ´ýSPI´«ÊäÍê³É
  72   1      
  73   1        return SPIRDAT;                       // ·µ»Ø¶Á³öÖµ
  74   1      }
  75          /**************************************************
  76          ¹¦ÄÜ£ºÐ´RF¼Ä´æÆ÷£¬¶ÁRF×´Ì¬Öµ
  77          **************************************************/
  78          uint8_t SPI_RW_Reg(uint8_t reg, uint8_t value)
  79          {
  80   1        uint8_t status;
  81   1      
  82   1          RFCSN = 0;                    
  83   1          status = SPI_RW(reg);               // Ñ¡ÔñRF¼Ä´æÆ÷
  84   1          SPI_RW(value);                      // Ð´ÈëÊý¾Ý
  85   1          RFCSN = 1;                    
  86   1      
  87   1          return(status);                     // ·µ»ØRF×´Ì¬Öµ
  88   1      }
  89          /**************************************************
  90          ¹¦ÄÜ£º¶ÁRF¼Ä´æÆ÷
  91          **************************************************/
  92          uint8_t SPI_Read(uint8_t reg)
  93          {
  94   1        uint8_t reg_val;
  95   1      
  96   1          RFCSN = 0;                      
  97   1          SPI_RW(reg);                      // Ñ¡ÔñRF¼Ä´æÆ÷
  98   1          reg_val = SPI_RW(0);              // ¶Á³öÊý¾Ý
  99   1          RFCSN = 1;                      
 100   1      
 101   1          return(reg_val);                  // ·µ»ØRF×´Ì¬Öµ
 102   1      }
 103          /**************************************************
 104          ¹¦ÄÜ£º¶ÁRF¼Ä´æÆ÷¶à×Ö½ÚÊý¾Ýµ½»º³åÇø
 105          **************************************************/
 106          uint8_t SPI_Read_Buf(uint8_t reg, uint8_t *pBuf, uint8_t bytes)
 107          {
 108   1        uint8_t status,byte_ctr;
 109   1      
 110   1          RFCSN = 0;                        
 111   1          status = SPI_RW(reg);               // Ñ¡ÔñRF¼Ä´æÆ÷
 112   1      
 113   1          for(byte_ctr=0;byte_ctr<bytes;byte_ctr++)
 114   1            pBuf[byte_ctr] = SPI_RW(0);         // Á¬½Ó¶Á³öÊý¾Ý
 115   1      
 116   1          RFCSN = 1;                          
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 3   

 117   1      
 118   1          return(status);                         // ·µ»ØRF×´Ì¬Öµ
 119   1      }
 120          /**************************************************
 121          ¹¦ÄÜ£º°Ñ»º³åÇøµÄ¶à×Ö½ÚÊý¾ÝÐ´µ½RF¼Ä´æÆ÷
 122          **************************************************/
 123          uint8_t SPI_Write_Buf(uint8_t reg, uint8_t *pBuf, uint8_t bytes)
 124          {
 125   1        uint8_t status,byte_ctr;
 126   1      
 127   1          RFCSN = 0;                      
 128   1          status = SPI_RW(reg);             // Ñ¡ÔñRF¼Ä´æÆ÷
 129   1          for(byte_ctr=0; byte_ctr<bytes; byte_ctr++) // Á¬½ÓÐ´ÈëÊý¾Ý
 130   1            SPI_RW(*pBuf++);
 131   1          RFCSN = 1;                      
 132   1          return(status);                   // ·µ»ØRF×´Ì¬Öµ
 133   1      }
 134          
 135          /**************************************************
 136          ¹¦ÄÜ£ºÉèÖÃÎª½ÓÊÕÄ£Ê½
 137          **************************************************/
 138          void RX_Mode(void)
 139          {
 140   1        RFCE=0;
 141   1          SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // ÉÏµç, CRCÎª2 bytes,½ÓÊÕÄ£Ê½,ÔÊÐíRX_DR²úÉúÖÐ¶Ï
 142   1          RFCE = 1;                   // Æô¶¯½ÓÊÕÄ£Ê½
 143   1      }
 144          
 145          /**************************************************
 146          ¹¦ÄÜ£ºÉèÖÃÎª·¢ÉäÄ£Ê½
 147          **************************************************/
 148          void TX_Mode(void)
 149          {
 150   1          RFCE=0;
 151   1          SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);           // ÉÏµç, CRCÎª2 bytes,½ÓÊÕÄ£Ê½,ÔÊÐíRX_DR²úÉúÖÐ¶Ï
 152   1          
 153   1        SPI_Write_Buf(WR_TX_PLOAD, tx_buf, TX_PLOAD_WIDTH); // Ð´Êý¾Ýµ½FIFO
 154   1        RFCE=1;                       // Æô¶¯·¢Éä                                       
 155   1      }
 156          
 157          /**************************************************
 158          ¹¦ÄÜ£ºRF³õÊ¼»¯
 159          **************************************************/
 160          void rf_init(void)
 161          {
 162   1          RFCE = 0;                                       // RF¹Ø±Õ
 163   1          RFCKEN = 1;                                     // Æô¶¯RFÊ±ÖÓ
 164   1          RF = 1;                                         // ÔÊÐíRFÖÐ¶Ï
 165   1      
 166   1        delay(1000);
 167   1      
 168   1          SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // ÉèÖÃ·¢ÉäµØÖ·³¤¶È
 169   1          SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, TX_ADR_WIDTH);  // ÉèÖÃ½ÓÊÕµØÖ·0³¤¶È
 170   1      //  SPI_Write_Buf(WRITE_REG + RX_ADDR_P1, RX_ADDRESS_P1, TX_ADR_WIDTH);   // ÉèÖÃ½ÓÊÕµØÖ·1³¤¶È
 171   1      
 172   1        SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);   // PIPE0 ½ÓÊÕÊý¾Ý°ü³¤¶È 
 173   1      //  SPI_RW_Reg(WRITE_REG + RX_PW_P1, TX_PLOAD_WIDTH);   // PIPE1 ½ÓÊÕÊý¾Ý°ü³¤¶È 
 174   1      
 175   1          SPI_RW_Reg(WRITE_REG + EN_AA, 0x03);            // Æô¶¯×Ô¶¯Ó¦´ð¹¦ÄÜ
 176   1          SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x03);        // PIPE½ÓÊÕÊý¾Ý
 177   1          SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x1a);       // ×Ô¶¯ÖØ´«10´Î
 178   1          SPI_RW_Reg(WRITE_REG + RF_CH, 40);              // RFÆµÂÊ2440MHz
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 4   

 179   1          SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x0f);         // ·¢Éä¹¦ÂÊ0dBm, ´«ÊäËÙÂÊ2Mbps,
 180   1            
 181   1      } 
 182          
 183          /**************************************************
 184          ¹¦ÄÜ£ºRFÖÐ¶Ï·þÎñ³ÌÐò
 185          **************************************************/
 186          void RF_IRQ(void) interrupt INTERRUPT_RFIRQ
 187          {
 188   1        sta=SPI_Read(STATUS);               // ¶Á³ö×´Ì¬Öµ
 189   1      
 190   1        if(RX_DR)                 
 191   1        {
 192   2          SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);// ¶Á³öFIFOµÄÊý¾Ý
 193   2          SPI_RW_Reg(FLUSH_RX,0);             // Çå³ýRXµÄFIFO
 194   2        }
 195   1      
 196   1        SPI_RW_Reg(WRITE_REG+STATUS,0x70);          // Çå³ýËùÓÐÖÐ¶Ï±êÖ¾ 
 197   1      }
 198          /**************************************************
 199          ¹¦ÄÜ£º´®¿Ú³õÊ¼»¯×Ó³ÌÐò
 200          ËµÃ÷£º²¨ÌØÂÊ9600£¬Ê¹ÓÃÄÚ²¿²¨ÌØÂÊ·¢ÉúÆ÷
 201          
 202          ²¨ÌØÂÊ      S0REL
 203          
 204          600          0x00BF
 205          1200         0X025F
 206          2400         0X0330
 207          4800         0X0398
 208          9600         0X03CC
 209          19200        0X03E6
 210          38400        0X03F3
 211          
 212          **************************************************/
 213          void uart_init(void)
 214          {
 215   1          ES0 = 0;                              // ¹ØUART0ÖÐ¶Ï
 216   1          REN0 = 1;                             // ÔÊÐí½ÓÊÕ
 217   1          SM0 = 0;                              // ´®¿ÚÄ£Ê½1£¬8bit¿É±ä²¨ÌØÂÊ
 218   1          SM1 = 1;                   
 219   1          PCON |= 0x80;                         // SMOD = 1
 220   1        
 221   1          ADCON |= 0x80;                        // Ñ¡ÔñÄÚ²¿²¨ÌØÂÊ·¢ÉúÆ÷
 222   1          S0RELL = 0xF3;                        // ²¨ÌØÂÊ38400
 223   1          S0RELH = 0x03;                
 224   1          TI0 = 0;                    // Çå·¢ËÍÍê³É±êÖ¾
 225   1          RI0=0;                       // Çå½ÓÊÕÍê³É±êÖ¾
 226   1          S0BUF=0x00;                   // ËÍ³õÖµ
 227   1      }
 228          /**************************************************
 229          ¹¦ÄÜ£ºÏò´®¿Ú·¢ËÍ1 byteÊý¾Ý
 230          **************************************************/
 231          void uart_putchar(uint8_t x)
 232          {
 233   1        while (!TI0);               // µÈ´ý·¢ËÍÍê³É
 234   1        TI0=0;                    // Çå·¢ËÍÍê³É±êÖ¾
 235   1        S0BUF=x;                  // ·¢ËÍÊý¾Ý
 236   1      }
 237          
 238          /**************************************************
 239          ¹¦ÄÜ£º´®¿Ú½ÓÊÕ1 byteÊý¾Ý
 240          **************************************************/
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 5   

 241          //uint8_t uart_receive_char(uint8_t x)
 242          //{
 243          //  while (!RI0);   // µÈ´ý·¢ËÍÍê³É
 244          //  RI0=0;      // Çå·¢ËÍÍê³É±êÖ¾
 245          //  x=S0BUF;    // ·¢ËÍÊý¾Ý
 246          //  return  x;
 247          //}
 248          
 249          /**************************************************
 250          ¹¦ÄÜ:I/O¿Ú³õÊ¼»¯
 251          **************************************************/
 252          void io_init(void)
 253          {
 254   1          P0DIR = p0dir;                  // Éè¶¨I/O¿ÚÊäÈëÊä³ö
 255   1          P1DIR = p1dir;          
 256   1        delay(1000);               
 257   1      }  
 258          
 259          
 260          /**************************************************
 261          ¹¦ÄÜ£ºÖ÷³ÌÐò
 262          **************************************************/
 263          void main(void)
 264          {
 265   1          uint8_t readerid=0x08;
 266   1      
 267   1        //½ÓÊÕµ½´®¿ÚÏÂ·¢µÄÖ¸Áî:0xdd 0x**ÇÐ»»±êÇ©¹¤×÷×´Ì¬»òÅäÖÃ±êÇ©ÉäÆµÐÅºÅÇ¿¶È  
 268   1        uint8_t yy[2]={0xff,0xff} ;   
 269   1        uint8_t  ii, j=0,  kk[2]={0,0}, tagpower[2]={0x0f,0x0f}, m=0, n=0;
 270   1        ii=0;
 271   1          
 272   1        io_init();                  // I/O¿Ú³õÊ¼»¯
 273   1        uart_init();                // ´®¿Ú³õÊ¼»¯   38400
 274   1        rf_init();                  // RF³õÊ¼»¯                            
 275   1        EA=1;                     // ÔÊÐíÖÐ¶Ï                          
 276   1      
 277   1        RX_Mode();     //½øÈë½ÓÊÕÄ£Ê½
 278   1        //SPIÅäÖÃ 
 279   1        SPIMCON0 = 0xF1;        //    6   5   4   3   2   1   0 
 280   1                 // 1 0 0 0 0 0 1
 281   1        SPISCON0 = 0xA1;        //    7 6   5   4   3   2   1   0 
 282   1                      //  1 0 1 0 0 0 0 1
 283   1        
 284   1        
 285   1        while(1)
 286   1        {
 287   2      //      rtc2_off();               // ¹ØRTC2 
 288   2          
 289   2        //    RX_Mode();     //½øÈë½ÓÊÕÄ£Ê½
 290   2          /***********************´®¿Ú½ÓÊÕ¸÷ÀàÖ¸Áî**********************/
 291   2      //    if (RI0=1)
 292   2      //    {
 293   2      //       RI0=0;     // Çå·¢ËÍÍê³É±êÖ¾
 294   2      //       yy[ii]=S0BUF;
 295   2      //       ii++;
 296   2      //       if (ii>=2) ii=0;
 297   2      //    }
 298   2      
 299   2      
 300   2          /***********0xdd 0x11/0x22 : ½ÓÊÕ»½ÐÑ/ÐÝÃß×´Ì¬±ä¸üÖ¸Áî£¬²¢ÏÂ·¢×´Ì¬±ä¸üÖ¸Áî¸øTAG**********/
 301   2          /**0xdd 0x09(0dBm)/0x0b(-6dBm)/0x0d(-12dBm)/0x0f(-18dBm) :½ÓÊÕÉäÆµ·¢Éä¹¦ÂÊÅäÖÃÖ¸Áî£¬²¢ÏÂ·¢ÉäÆµ¹¦ÂÊÅäÖÃ¸ø
             -±êÇ©**/
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 6   

 302   2      //    if(yy[0]==0xdd)
 303   2      //    {
 304   2      //        if(yy[1]!=0)
 305   2      //          {
 306   2      //             tx_buf[0]=yy[1];
 307   2      //         if(tx_buf[0]!=0xdd)
 308   2      //         {
 309   2      //               for(j=0;j<180;j++)
 310   2      //               {
 311   2      //                 TX_Mode();               // ·¢ÉäÊý¾Ý
 312   2      //                 while (!(TX_DS|MAX_RT));       // µÈ´ý·¢Éä½áÊø
 313   2      //                 sta = 0;
 314   2      //               }
 315   2      //               RX_Mode();
 316   2      //              }
 317   2      //       } 
 318   2      //    } 
 319   2      
 320   2      //    if(yy[1]==0xdd)
 321   2      //    {
 322   2      //        if(yy[0]!=0)
 323   2      //          {
 324   2      //             tx_buf[0]=yy[0];
 325   2      //         if(tx_buf[0]!=0xdd)
 326   2      //         {
 327   2      //               for(j=0;j<180;j++)
 328   2      //               {
 329   2      //                 TX_Mode();               // ·¢ÉäÊý¾Ý
 330   2      //                 while (!(TX_DS|MAX_RT));       // µÈ´ý·¢Éä½áÊø
 331   2      //                 sta = 0;
 332   2      //               }
 333   2      //               RX_Mode();
 334   2      //             }
 335   2      //      }
 336   2      //    }      
 337   2      
 338   2      
 339   2          /*****Ö±½Ó½ÓÊÕ±êÇ©µÄIDÐÅÏ¢,
 340   2          »ò¼ä½ÓÍ¨¹ýSPI½ÓÊÕ´Ó¶ÁÐ´Ä£¿éSlaveReaderÊ¶±ðµ½µÄ±êÇ©IDÐÅÏ¢*****/
 341   2              {
 342   3      //            if (spi_cs_slave==0)
 343   3      //              {  
 344   3      //                 for(jj=0;jj<52;jj++);
 345   3      //               kk[0]= SPISDAT;
 346   3      //               //for(jj=0;jj<50;jj++);
 347   3      //               //kk[1]=SPISDAT;
 348   3      //           
 349   3      //           /***********×éÖ¡ÉÏ´«´®¿Ú************/
 350   3      //           uart_putchar(0xFB);   
 351   3      //           uart_putchar(0x10);                     
 352   3      //             uart_putchar(0);
 353   3      //           uart_putchar(0);                        
 354   3      //             uart_putchar(kk[0]); 
 355   3      //           uart_putchar(kk[1]);                      
 356   3      //             uart_putchar(readerid);  
 357   3      //           uart_putchar(0x02);  
 358   3      //              }
 359   3      
 360   3              if(RX_DR)               // Êý¾ÝÒÑÊÕµ½
 361   3              {
 362   4                sta=0;
 363   4                /***********×éÖ¡ÉÏ´«¸ø´®¿Ú************/
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 7   

 364   4      //          uart_putchar(0xFB);
 365   4      //          uart_putchar(0x10);                      
 366   4      //          uart_putchar(0);  
 367   4      //          uart_putchar(0);                       
 368   4      //          uart_putchar(rx_buf[0]);  
 369   4      //          uart_putchar(rx_buf[1]);                       
 370   4      //          uart_putchar(readerid);
 371   4      //          uart_putchar(0x01); 
 372   4                uart_putchar(0x2A);       
 373   4                uart_putchar(0x20);             
 374   4                uart_putchar(rx_buf[0]);  
 375   4                uart_putchar(rx_buf[1]);
 376   4                uart_putchar(rx_buf[2]);
 377   4                uart_putchar(rx_buf[3]);
 378   4                uart_putchar(rx_buf[4]);
 379   4                uart_putchar(rx_buf[5]);
 380   4                uart_putchar(rx_buf[6]);
 381   4                uart_putchar(rx_buf[7]);
 382   4                uart_putchar(rx_buf[8]);
 383   4                uart_putchar(rx_buf[9]);
 384   4                uart_putchar(rx_buf[10]);         
 385   4                uart_putchar(rx_buf[11]);
 386   4                uart_putchar(rx_buf[12]);
 387   4                uart_putchar(rx_buf[13]);
 388   4                uart_putchar(rx_buf[14]); 
 389   4                uart_putchar(rx_buf[15]);
 390   4                uart_putchar(rx_buf[16]);
 391   4                uart_putchar(rx_buf[17]);
 392   4                uart_putchar(rx_buf[18]);
 393   4                uart_putchar(rx_buf[19]);
 394   4                uart_putchar(rx_buf[20]);
 395   4                uart_putchar(rx_buf[21]);
 396   4                uart_putchar(rx_buf[22]);
 397   4                uart_putchar(rx_buf[23]);
 398   4                uart_putchar(rx_buf[24]);         
 399   4                uart_putchar(rx_buf[25]);
 400   4                uart_putchar(rx_buf[26]);
 401   4                uart_putchar(rx_buf[27]);         
 402   4                uart_putchar(rx_buf[28]);
 403   4                uart_putchar(rx_buf[29]);
 404   4                uart_putchar(rx_buf[30]);
 405   4                uart_putchar(rx_buf[31]);
 406   4                uart_putchar(0x7E); 
 407   4                uart_putchar(0x7E); 
 408   4                uart_putchar(0x7E); 
 409   4                
 410   4      //          uart_putchar(rx_buf[32]);                     
 411   4              } 
 412   3          }
 413   2              
 414   2          //uart_putchar(0x10);   
 415   2        } 
 416   1      }                     


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    711    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58      21
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   MAIN                                                              08/04/2020 09:45:47 PAGE 8   

   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
